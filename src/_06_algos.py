""" More complicated algorithms. 
"""

import math
from typing import List


def gcd(n: int,  m: int) -> int:
    """Find the greated common denominator between n and m

    Args:
        n (int): [description]
        m (int): [description]

    Returns:
        int: [description]
    """
    # ** before you code it ... write out the steps here.
    '''
    1. gcd start at 1 
    2. use for loop to serach for n % i == 0 and m % == 0 
    3. reassign gcd to ith value in range(1, n+1), nth inclusive
    '''
    if n == m == 0:
        raise ValueError('n and m cannot be 0') 
    gcd = 1
    for i in range(1, n + 1):
        if n % i == 0 and m % i == 0:
            gcd = i 
    # return gcd # explicit solution 
    return math.gcd(n, m) # using math import 



# NOTE this is based on https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
def primes_below(n: int) -> List[int]:
    """Find all prime numbers below the number n 

    Args:
        n (int): [description]

    Returns:
        List[int]: [description]
    """
    # ** before you code it... write out the steps here...
    '''
    1. find prime_nums from 2 - nth prime (n exclusive)
    2. iterate thr n to find primes and pass each num in n to is_prime(num) 
        EX: n = 10 => [2, 3, 5, 7]
    NOTE two solution provided one with list comprehension the other explicit. 
    '''
    # if n <= 1:
    #     raise ValueError('n cannot be negative')
    # elif n == 2:
    #     return [2]
    # list_of_primes = []
    # for num in range(n):
    #     if num > 1: 
    #         for i in range(2, num):
    #             if not num % i:
    #                 break # return False 
    #         else: # if num > 1 and True 
    #             list_of_primes.append(num)
    # return list_of_primes
    if n <= 1:
        raise ValueError('n cannot be negative')
    elif n == 2:
        return [2]
    return [num for num in range(n) if is_prime(num) and num > 1]

def is_prime(num):
    for i in range(2,num):
        if not num % i: #even%2 => falsey
            return False 
    return True 



def sum_of_even_fibonacci_number_for_nth_term(n: int) -> int:
    """Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
    By starting with 1 and 2, the first 10 terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    With n greater than or equal to 100, by considering the terms up to nth terms (including nth terms)in the Fibonacci sequence, 
    find the sum of the even-valued terms. Raise error if the value of n is less than 100.

    Hint: Use golden ratio to find, fiobnacci terms.
    Please note that here Fibonacci sequence start at one and not zero
    and python might give you float instead of int.
    Bonus: Try not to use if statements.
    """
    #⚠️ if n < 100 meets specs but does not pass test 
    #⚠️ golden ratio derived from feb_seq, not sure how to use it without having feb_seq established 
    if n <= 1:
        return 0
    fib_seq = [1,2]
    for i in range(n-2): 
        fib_seq.append(fib_seq[i] + fib_seq[i + 1])
    return sum(filter(lambda fib_num: not fib_num % 2, fib_seq))



def two_sum(nums: List[int], target: int) -> List[int]:
    """Given an array of integers nums and an integer target, 
    return indices of the first two numbers such that they add up to target.

    You may assume that each input would have exactly one solution.

    ex. 
    >>> nums = [2,7,11,15], target = 9
    ... [0,1]
    >>> nums = [3,2,3], target = 6 
    ... [0,2]
    >>> nums = [3,3], target = 6 
    ... [0,1]

    Args:
        nums (List[int]): [description]
        target (int): [description]

    Returns:
        List[int]: [description]
    """

    for i in range(len(nums)):
        for j in range(1, len(nums)):
            if j > i and (nums[i] + nums[j]) == target:
                return [i,j]



def reverse(x: int) -> int:
    """Given a signed 32-bit integer x, return x with its digits reversed. 
    If reversing x causes the value to go outside the signed 32-bit integer 
    range [-2**31, 2**31 - 1], then return 0.

    ex. 
    >>> x = 123
    ... 321 
    >>> x = -123 
    ... -321
    >>> x = 120 
    ... 21 
    >>> x = 0 
    ... 0 

    Args:
        x (int): [description]

    Returns:
        int: [description]
    """
    if x < 0:
        result = -int(str(abs(x))[::-1])# reverse str and int convert
    else:
        result = int(str(abs(x))[::-1])
    return 0 if result not in range((-2**31), 2**31 - 1) else result

